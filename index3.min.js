!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.supermodels=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var createDef = _dereq_('./lib/def');
var createModelPrototype = _dereq_('./lib/proto');
var Supermodel = _dereq_('./lib/supermodel');

function supermodels(schema, initializer, parent) {
  
  var def = createDef(schema);
  
  // Wrap any simple definitions
  // in an object with a value property
  // if (def.isSimple) {
  //   def = createDef({
  //     value: from
  //   });
  // }
  
  function SupermodelConstructor() {
    var model = def.isSimple ? def.create(parent) : def.create(parent).value;

    // Call any initializer
    if (initializer) {
      initializer.apply(model, arguments);
    }
    
    return model;
  }
  Object.defineProperty(SupermodelConstructor, 'def', {
    value: def // this is used to validate referenced SupermodelConstructors
  })
  SupermodelConstructor.prototype = Supermodel; // this shared object is used, as a prototype, to identify SupermodelConstructors
  SupermodelConstructor.constructor = SupermodelConstructor;
  
  return SupermodelConstructor;
}

module.exports = supermodels;
},{"./lib/def":2,"./lib/proto":5,"./lib/supermodel":6}],2:[function(_dereq_,module,exports){
var util = _dereq_('./util');
var createWrapperFactory = _dereq_('./factory');

function resolve(from) {
  var isCtor = util.isConstructor(from);
  var isSupermodelCtor = util.isSupermodelConstructor(from);
  var isArray = util.isArray(from);

  if (isCtor || isSupermodelCtor || isArray) {
    return {
      __type: from
    };
  }

  var isValue = !util.isObject(from);
  if (isValue) {
    return {
      __value: from
    };
  }

  return from;
}

function createDef(from) {

  from = resolve(from);

  var __VALIDATORS = '__validators',
    __VALUE = '__value',
    __TYPE = '__type',
    __DISPLAYNAME = '__displayName',
    __GET = '__get',
    __SET = '__set',
    __ENUMERABLE = '__enumerable',
    __CONFIGURABLE = '__configurable',
    __WRITABLE = '__writable',
    __SPECIAL_PROPS = [__VALIDATORS, __VALUE, __TYPE, __DISPLAYNAME, __GET, __SET, __ENUMERABLE, __CONFIGURABLE, __WRITABLE];

  var def = {
    from: from,
    type: from[__TYPE],
    value: from[__VALUE],
    validators: from[__VALIDATORS] || [],
    enumerable: from[__ENUMERABLE] === false ? false : true,
    configurable: from[__CONFIGURABLE] ? true : false,
    writable: from[__WRITABLE] === false ? false : true,
    displayName: from[__DISPLAYNAME],
    getter: from[__GET],
    setter: from[__SET]
  };

  var type = def.type;
  
  // Simple 'Constructor' Type
  if (util.isSimpleConstructor(type)) {

    def.isSimple = true;

    def.cast = function(value) {
      return util.cast(value, type);
    };

  } else if (util.isSupermodelConstructor(type)) {
    def.isReference = true;
  } else if (!def.value) {

    // If a value is present, use 
    // that and short-circuit the rest
    // otherwise look for other non-special
    // keys and also any item definition
    // in the case of Arrays
    
    var keys = Object.keys(from);
    var childKeys = keys.filter(function(item) {
      return __SPECIAL_PROPS.indexOf(item) === -1;
    });

    if (childKeys.length) {
      
      var defs = {};
      var proto;
      
      childKeys.forEach(function(key) {
        var value = from[key];
        if (!util.isConstructor(value) && !util.isSupermodelConstructor(value) && util.isFunction(value)) {
          if (!proto) {
            proto = {};
          }
          proto[key] = value;
        } else {
          defs[key] = createDef(value);
        }
      });
      
      def.defs = defs;
      def.proto = proto;

    }
    
    // Check for Array
    if (type === Array || util.isArray(type)) {

      def.isArray = true;

      if (type.length > 0) {
        def.def = createDef(type[0]);
      }

    }
    
  }

  def.create = createWrapperFactory(def);
  
  return def;
}

module.exports = createDef;
},{"./factory":3,"./util":7}],3:[function(_dereq_,module,exports){
/**
 * A Model Value encapsulates the value part of an object
 * Given an object { a: 1 }, the value part would be the '1'.
 * The key part is 'a'. A 'property' is a combination of both.
 * 
 * We encapsulate the value part here and provide a getter, setter
 * to enable us to proxy (and report) any changes to a property
 */

var util = _dereq_('./util');
var createModelPrototype = _dereq_('./proto');
var Wrapper = _dereq_('./wrapper');

function createModelDescriptors(def, parent) {
  
  var __ = {};
  
  var desc = {
    __: {
      value: __
    },
    __def: {
      value: def
    },
    __parent: {
      value: parent,
      writable: true
    }
  };
  
  return desc;
}

function defineProperties(model) {
  var defs = model.__def.defs;
  for (var key in defs) {
    defineProperty(model, key, defs[key]);
  }
}

function defineProperty(model, key, def) {

  var caster = def.cast;
  var desc = {
    get: function() {
      return this.__get(key);
    },
    enumerable: def.enumerable,
    configurable: def.configurable
  };

  if (def.writable) {
    desc.set = function(value) {
      this.__setNotifyChange(key, value);
    };
  }

  Object.defineProperty(model, key, desc);
  
  // Silently initialize the property value
  model.__[key] = def.create(model);
}

function createWrapperFactory(def) {
  
  var wrapper, deaultValue, assert;
  
  if (def.isSimple) {
    wrapper = new Wrapper(def.value, def.writable, def.validators, def.cast, null);
  } else if (def.isReference) {

    // Hold a reference to the 
    // refererenced types' definition
    var refDef = def.type.def;
    
    if (refDef.isSimple) {
      // If the referenced type is itself simple, 
      // we can set just return a wrapper and
      // the property will get initialized.
      wrapper = new Wrapper(refDef.value, refDef.writable, refDef.validators, refDef.cast, null);
    } else {
      
      // If we're not dealing with a simple reference model
      // we need to define an assertion that the instance
      // being set is of the correct type. We do this be 
      // comparing the defs.
      
      assert = function(value) {
        // compare the defintions of the value instance
        // being passed and the def property attached
        // to the type SupermodelConstructor. Allow the
        // value to be undefined or null also.
        var isCorrectType = false;
        
        if (util.isNullOrUndefined(value)) {
          isCorrectType = true;
        } else {
          isCorrectType = refDef === value.__def;
        }
        
        if (!isCorrectType) {
          throw new Error('Value should be an instance of the referenced model, null or undefined');
        }
      };
  
      wrapper = new Wrapper(def.value, def.writable, def.validators, null, assert);
      
    }
    
  } else if (def.isArray) {
    
    defaultValue = function(parent) {
      // for Arrays, we create a new Array and each
      // time, mixing the model properties into it
      var model = createModelPrototype(def);
      Object.defineProperties(model, createModelDescriptors(def, parent));
      defineProperties(model);
      return model;
    };
    
    assert = function(value) {
      // todo: further type validation
      if (!util.isArray(value)) {
        throw new Error('Value should be an array');
      }
    };
    
    wrapper = new Wrapper(defaultValue, def.writable, def.validators, null, assert);
    
  } else {
    
    // for Objects, we can create and reuse 
    // a prototype object. We then need to only
    // define the defs and the `runtime` properties
    // e.g. __, parent etc.
    var proto = createModelPrototype(def);
    
    defaultValue = function(parent) {
      var model = Object.create(proto, createModelDescriptors(def, parent));
      defineProperties(model);
      return model;
    };
    
    assert = function(value) {
      if (!proto.isPrototypeOf(value)) {
        throw new Error('Invalid prototype');
      }
    };
    
    wrapper = new Wrapper(defaultValue, def.writable, def.validators, null, assert);
  }
  
  var factory = function(parent) {
    var w = Object.create(wrapper);
    if (!w.isInitialized) {
      w.initialize(parent);
    }
    return w;
  };
  
  // expose the wrapper, this is useful 
  // for validating array items later
  factory.wrapper = wrapper;
  
  return factory;
}


module.exports = createWrapperFactory;
},{"./proto":5,"./util":7,"./wrapper":9}],4:[function(_dereq_,module,exports){
var EmitterEvent = _dereq_('emitter-event');
var ValidationError = _dereq_('./validation-error');
//var Wrapper = require('./wrapper');

var descriptors = {
  __supermodel: {
    value: true
  },
  __keys: {
    get: function() {
      var keys = Object.keys(this);
      
      if (Array.isArray(this)) {
        var omit = [
          'addEventListener', 'on', 'once', 'removeEventListener', 'removeAllListeners',
          'removeListener', 'off', 'emit', 'listeners', 'hasListeners', 'pop', 'push',
          'reverse', 'shift', 'sort', 'splice', 'update', 'unshift', 'create',
           '__setNotifyChange', '__notifyChange', '__set', '__get'
        ];
  
        keys = keys.filter(function(item) {
          return omit.indexOf(item) < 0;
        });
      }

      return keys;
    }
  },
  __name: {
    get: function() {
      if (this.__isRoot) {
        return '';
      }

      // Work out the 'name' of the model
      // Look up to the parent and loop through it's keys,
      // Any value or array found to contain the value of this (this model)
      // then we return the key and index in the case we found the model in an array.
      var parentKeys = this.__parent.__keys;
      var parentKey, parentValue, isArray;

      for (var i = 0; i < parentKeys.length; i++) {
        parentKey = parentKeys[i];
        parentValue = this.__parent[parentKey];
        isArray = Array.isArray(parentValue);

        if (parentValue === this) {
          return parentKey;
        }
      }
    }
  },
  __path: {
    get: function() {
      if (this.__hasAncestors && !this.__parent.__isRoot) {
        return this.__parent.__path + '.' + this.__name;
      } else {
        return this.__name;
      }
    }
  },
  __isRoot: {
    get: function() {
      return !this.__hasAncestors;
    }
  },
  __children: {
    get: function() {
      var children = [];

      var keys = this.__keys;
      var key, value;

      for (var i = 0; i < keys.length; i++) {

        key = keys[i];
        value = this[key];

        if (value && value.__supermodel) {

          children.push(value);

        }
      }

      return children;
    }
  },
  __ancestors: {
    get: function() {
      var ancestors = [],
        r = this;

      while (r.__parent) {
        ancestors.push(r.__parent);
        r = r.__parent;
      }

      return ancestors;
    }
  },
  __descendants: {
    get: function() {
      var descendants = [];

      function checkAndAddDescendantIfModel(obj) {

        var keys = obj.__keys;
        var key, value;

        for (var i = 0; i < keys.length; i++) {

          key = keys[i];
          value = obj[key];

          if (value && value.__supermodel) {

            descendants.push(value);
            checkAndAddDescendantIfModel(value);

          }
        }

      }

      checkAndAddDescendantIfModel(this);

      return descendants;
    }
  },
  __hasAncestors: {
    get: function() {
      return !!this.__ancestors.length;
    }
  },
  __hasDecendants: {
    get: function() {
      return !!this.__descendants.length;
    }
  },
  errors: {
    get: function() {
      var errors = [];
      var validators = this.__validators;
      var validator, key, error, child, i;

      if (validators) {

        for (i = 0; i < validators.length; i++) {
          validator = validators[i];
          key = validator.key;
          error = validator.test.call(this, key ? this[key] : this, key);

          if (error) {
            errors.push(new ValidationError(this, error, validator, key));
          }
        }
      }

      for (i = 0; i < this.__children.length; i++) {
        child = this.__children[i];
        Array.prototype.push.apply(errors, child.errors);
      }

      return errors;
    }
  }
};

var proto = {
  __get: function(key) {
    return this.__[key].value;
  },
  __set: function(key, value) {

    if (value && value.__supermodel) {
      if (value.__parent !== this) {
        value.__parent = this;
      }
    }
    
    // Accomodate for the case of the 
    // value already being a Wrapper instance
    // if (value instanceof Wrapper) {
    //   this.__[key] = value;
    // } else {
      this.__[key].value = value;
    // }

    var newValue = this.__get[key];
  },
  __notifyChange: function(key, newValue, oldValue) {
    // Emit change event against this model
    this.emit('change', new EmitterEvent('change', this, {
      name: key,
      value: newValue,
      oldValue: oldValue
    }));

    // Emit specific key change event against this model
    this.emit('change:' + key, new EmitterEvent('change:' + key, this, {
      value: newValue,
      oldValue: oldValue
    }));

    // Bubble the change event up against the ancestors
    var name;
    for (var i = 0; i < this.__ancestors.length; i++) {

      name = this.__path + '.' + key;

      // Emit change event against this ancestor
      this.__ancestors[i].emit('change', new EmitterEvent('change', this, {
        name: name,
        value: newValue,
        oldValue: oldValue
      }));

      // Emit specific change event against this ancestor
      this.__ancestors[i].emit('change:' + name, new EmitterEvent('change:' + name, this, {
        name: name,
        value: newValue,
        oldValue: oldValue
      }));
    }
  },
  __setNotifyChange: function(key, value) {
    var oldValue = this.__get(key);
    this.__set(key, value);
    var newValue = this.__get(key);
    this.__notifyChange(key, newValue, oldValue);
  }
};

module.exports = {
  proto: proto,
  descriptors: descriptors,
};
},{"./validation-error":8,"emitter-event":13}],5:[function(_dereq_,module,exports){
var emitter = _dereq_('emitter-object');
var emitterArray = _dereq_('emitter-array');

var extend = _dereq_('./util').extend;
var modelProto = _dereq_('./model').proto;
var modelDescriptors = _dereq_('./model').descriptors;

var modelPrototype = Object.create(modelProto, modelDescriptors);
var objectPrototype = (function () {

  var p = Object.create(modelPrototype);
  
  emitter(p);
  
  return p;
})();


function createArrayPrototype() {

  var p = emitterArray(function() {}); 
  
  Object.defineProperties(p, modelDescriptors);
  
  emitter(p);
  
  extend(p, modelProto);
  
  return p;
}

function createObjectModelPrototype(proto) {
  if (proto) {
    return Object.create(extend(proto, objectPrototype));
  } else {
    return Object.create(objectPrototype);
  }
}

function createArrayModelPrototype(proto, itemDef) {
  
  // We do not to attempt to subclass Array,
  // instead create a new instance each time 
  var p = createArrayPrototype();
  
  if (proto) {
    extend(p, proto);
  }

  if (itemDef) {
    
    // We have a definition for the items 
    // that belong in this array.
      
    // Use the `wrapper` prototype property as a 
    // virtual Wrapper object we can use 
    // validate the items in the array.
    var arrItemWrapper = itemDef.create.wrapper;

    // Validate new models by overriding the emitter array 
    // mutators that can cause new items to enter the array
    overrideArrayAddingMutators(p, arrItemWrapper);

    // Provide a convenient model factory 
    // for creating array item instances
    if (!itemDef.isSimple) {
      p.create = function() {
        return itemDef.create(this).value;
      };
    }
  }
  
  return p;
}

function wrapArrayItems(itemWrapper, items) {
  var args = [], val;
  for (var i = 0; i < items.length; i++) {
    itemWrapper.value = items[i];
    args.push(itemWrapper.value);
  }
  return args;
}

function overrideArrayAddingMutators(arr, itemWrapper) {
  
  var push = arr.push;
  var unshift = arr.unshift;
  var splice = arr.splice;

  if (push) {
    arr.push = function() {
      var args = wrapArrayItems(itemWrapper, arguments);
      return push.apply(arr, args);
    };
  }

  if (unshift) {
    arr.unshift = function() {
      var args = wrapArrayItems(itemWrapper, arguments);
      return unshift.apply(arr, args);
    };
  }

  if (splice) {
    arr.splice = function() {
      var args = wrapArrayItems(itemWrapper, Array.prototype.slice.call(arguments, 2));
      args.unshift(arguments[1]);
      args.unshift(arguments[0]);
      return splice.apply(arr, args);
    };
  }
}

function createModelPrototype(def) {
  return def.isArray ? createArrayModelPrototype(def.proto, def.def) : createObjectModelPrototype(def.proto);
}

module.exports = createModelPrototype;
},{"./model":4,"./util":7,"emitter-array":10,"emitter-object":14}],6:[function(_dereq_,module,exports){
module.exports = {};
},{}],7:[function(_dereq_,module,exports){
var Supermodel = _dereq_('./supermodel');

function extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || typeof add !== 'object') return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

var util = {
  extend: extend,
  typeOf: function(obj) {
    return Object.prototype.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  },
  isObject: function(value) {
    return this.typeOf(value) === 'object';
  },
  isArray: function(value) {
    return Array.isArray(value);
  },
  isSimple: function(value) {
    // 'Simple' here means anything 
    // other than an Object or an Array
    // i.e. number, string, date, bool, null, undefined, regex...
    return !this.isObject(value) && !this.isArray(value);
  },
  isFunction: function(value) {
    return this.typeOf(value) === 'function';
  },
  isDate: function(value) {
    return this.typeOf(value) === 'date';
  },
  isNull: function(value) {
    return value === null;
  },
  isUndefined: function(value) {
    return typeof(value) === 'undefined';
  },
  isNullOrUndefined: function(value) {
    return this.isNull(value) || this.isUndefined(value);
  },
  cast: function(value, type) {
    if (!type) {
      return value;
    }

    switch (type) {
      case String:
        return util.castString(value);
      case Number:
        return util.castNumber(value);
      case Boolean:
        return util.castBoolean(value);
      case Date:
        return util.castDate(value);
      case Object:
      case Function:
        return value;
      default:
        throw new Error('Invalid cast');
    }
  },
  castString: function(value) {
    if (value === undefined || value === null || util.typeOf(value) === 'string') {
      return value;
    }
    return value.toString && value.toString();
  },
  castNumber: function(value) {
    if (value === undefined || value === null) {
      return NaN;
    }
    if (util.typeOf(value) === 'number') {
      return value;
    }
    return Number(value);
  },
  castBoolean: function(value) {
    if (!value) {
      return false;
    }
    var falsey = ['0', 'false', 'off', 'no'];
    return falsey.indexOf(value) === -1;
  },
  castDate: function(value) {
    if (value === undefined || value === null || util.typeOf(value) === 'date') {
      return value;
    }
    return new Date(value);
  },
  isConstructor: function(value) {
    return this.isSimpleConstructor(value) || !!~[Array, Object].indexOf(value);
  },
  isSimpleConstructor: function(value) {
    return !!~[String, Number, Date, Boolean].indexOf(value);
  },
  isSupermodelConstructor: function(value) {
    return this.isFunction(value) && value.prototype === Supermodel;
  }
};

module.exports = util;
},{"./supermodel":6}],8:[function(_dereq_,module,exports){
function ValidationError(target, error, validator, key) {
  this.target = target;
  this.error = error;
  this.validator = validator;

  if (key) {
    this.key = key;
  }
}

module.exports = ValidationError;
},{}],9:[function(_dereq_,module,exports){
/**
 * A Model Value encapsulates the value part of an object
 * Given an object { a: 1 }, the value part would be the '1'.
 * The key part is 'a'. A 'property' is a combination of both.
 * 
 * We encapsulate the value part here and provide a getter, setter
 * to enable us to proxy (and report) any changes to a property
 */

// function Box(context, key, value, cast, validators, assert) {
//   this._context = context;
//   this._key = key;
// }
// Object.defineProperties(Box.prototype, {
//   errors: {
//     get: function() {
//       var errors = [];
//       var key = this._key;
//       var context = this._context;
//       var validators = this._wrapper.validators;
      
//       for (var i = 0; i < validators.length; i++) {
//         validator = validators[i];
//         key = validator.key;
//         error = validator.test.call(context, key ? context[key] : context, key);
  
//         if (error) {
//           errors.push(new ValidationError(this, error, validator, key));
//         }
//       }
      
//       return errors;
//     }
//   }
// });

var util = _dereq_('./util');

function Wrapper(defaultValue, writable, validators, beforeSet, assert) {
  this.validators = validators;
  
  this._defaultValue = defaultValue;
  this._writable = writable;
  this._beforeSet = beforeSet;
  this._assert = assert;
  this.isInitialized = false;
  
  if (!util.isFunction(defaultValue)) {
    this.isInitialized = true;
    
    if (!util.isUndefined(defaultValue)) {
      this.value = defaultValue;
    }
  }
}
Wrapper.prototype.initialize = function(parent) {
  if (this.isInitialized) {
    return;
  }
  this.value = this._defaultValue(parent);
  this.isInitialized = true;
};
Object.defineProperties(Wrapper.prototype, {
  value: {
    get: function() {
      return this._getter ? this._getter() : this._value;
    },
    set: function(value) {
      
      if (!this._writable) {
        throw new Error('Value is readonly');
      }
      
      //def.setter.call(this, value);
      var val = this._beforeSet ? this._beforeSet(value) : value;
      
      if (this._assert) {
        this._assert(val);
      }
      
      this._value = val;
    }
  }
});

module.exports = Wrapper;
},{"./util":7}],10:[function(_dereq_,module,exports){
var Emitter = _dereq_('emitter-object');
var EmitterEvent = _dereq_('emitter-event');

function result(name, arr, value) {
  var e = new EmitterEvent(name, arr, value);

  arr.emit(name, e);
  arr.emit('change', e);
}

module.exports = function(callback) {

  callback = callback || raiseEvent;
  
  /**
   * Construct an Array from the passed arguments
   */
  var arrCtorArgs = arguments;
  var arr = [];//Array.apply(null, arrCtorArgs);

  /**
   * Mixin Emitter to the Array instance
   */
  if (!callback) Emitter(arr);

  /**
   * Proxied array mutators methods
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */
  var pop = function() {

    var result = Array.prototype.pop.apply(arr);

    callback('pop', arr, { value: result });

    return result;
  };
  var push = function() {

    var result = Array.prototype.push.apply(arr, arguments);

    callback('push', arr, { value: result });

    return result;
  };
  var reverse = function() {

    var result = Array.prototype.reverse.apply(arr);

    callback('reverse', arr, { value: result });

    return result;
  };
  var shift = function() {

    var result = Array.prototype.shift.apply(arr);

    callback('shift', arr, { value: result });

    return result;
  };
  var sort = function() {

    var result = Array.prototype.sort.apply(arr, arguments);

    callback('sort', arr, { value: result });

    return result;
  };
  var unshift = function() {

    var result = Array.prototype.unshift.apply(arr, arguments);

    callback('unshift', arr, { value: result });

    return result;
  };
  var splice = function() {

    if (!arguments.length) {
      return;
    }

    var result = Array.prototype.splice.apply(arr, arguments);

    callback('splice', arr, {
      value: result,
      removed: result,
      added: Array.prototype.slice.call(arguments, 2)
    });

    return result;
  };

  /**
   * Proxy all Array.prototype mutator methods on this array instance
   */
  arr.pop = arr.pop && pop;
  arr.push = arr.push && push;
  arr.reverse = arr.reverse && reverse;
  arr.shift = arr.shift && shift;
  arr.sort = arr.sort && sort;
  arr.splice = arr.splice && splice;

  /**
   * Special update function
   */
  arr.update = function(index, value) {

    var oldValue = arr[index];
    var newValue = arr[index] = value;

    callback('update', arr, {
      value: newValue,
      oldValue: oldValue
    });

    return newValue;
  };

  return arr;
};
},{"emitter-event":11,"emitter-object":12}],11:[function(_dereq_,module,exports){
module.exports = function EmitterEvent(name, target, detail) {
  this.name = name;
  this.target = target;
  
  if (detail) {
    this.detail = detail;
  }
};
},{}],12:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  var ctx = obj || this;
  
  var callbacks;
  Object.defineProperty(ctx, '__callbacks', {
    get: function() {
      return callbacks = callbacks || {};
    },
    set: function(value) {
      callbacks = value;
    }
  });
  
  if (obj) {
    ctx = mixin(obj);
    return ctx;
  }
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  (this.__callbacks[event] = this.__callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  
  // all
  if (0 == arguments.length) {
    this.__callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this.__callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this.__callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event) {
  var args = [].slice.call(arguments, 1)
    , callbacks = this.__callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event) {
  return this.__callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

},{}],13:[function(_dereq_,module,exports){
module.exports=_dereq_(11)
},{}],14:[function(_dereq_,module,exports){
module.exports=_dereq_(12)
},{}]},{},[1])
(1)
});