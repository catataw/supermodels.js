var EmitterEvent = require('./emitter-event');
var ValidationError = require('./validation-error');
var Wrapper = require('./wrapper');

var descriptors = {
  __supermodel: {
    value: true
  },
  __keys: {
    get: function() {
      var keys = Object.keys(this);

      if (Array.isArray(this)) {
        var omit = [
          'addEventListener', 'on', 'once', 'removeEventListener', 'removeAllListeners',
          'removeListener', 'off', 'emit', 'listeners', 'hasListeners', 'pop', 'push',
          'reverse', 'shift', 'sort', 'splice', 'update', 'unshift', 'create',
          '__setNotifyChange', '__notifyChange', '__set', '__get'
        ];

        keys = keys.filter(function(item) {
          return omit.indexOf(item) < 0;
        });
      }

      return keys;
    }
  },
  __name: {
    get: function() {
      if (this.__isRoot) {
        return '';
      }

      // Work out the 'name' of the model
      // Look up to the parent and loop through it's keys,
      // Any value or array found to contain the value of this (this model)
      // then we return the key and index in the case we found the model in an array.
      var parentKeys = this.__parent.__keys;
      var parentKey, parentValue, isArray;

      for (var i = 0; i < parentKeys.length; i++) {
        parentKey = parentKeys[i];
        parentValue = this.__parent[parentKey];
        isArray = Array.isArray(parentValue);

        if (parentValue === this) {
          return parentKey;
        }
      }
    }
  },
  __path: {
    get: function() {
      if (this.__hasAncestors && !this.__parent.__isRoot) {
        return this.__parent.__path + '.' + this.__name;
      } else {
        return this.__name;
      }
    }
  },
  __isRoot: {
    get: function() {
      return !this.__hasAncestors;
    }
  },
  __children: {
    get: function() {
      var children = [];

      var keys = this.__keys;
      var key, value;

      for (var i = 0; i < keys.length; i++) {

        key = keys[i];
        value = this[key];

        if (value && value.__supermodel) {

          children.push(value);

        }
      }

      return children;
    }
  },
  __ancestors: {
    get: function() {
      var ancestors = [],
        r = this;

      while (r.__parent) {
        ancestors.push(r.__parent);
        r = r.__parent;
      }

      return ancestors;
    }
  },
  __descendants: {
    get: function() {
      var descendants = [];

      function checkAndAddDescendantIfModel(obj) {

        var keys = obj.__keys;
        var key, value;

        for (var i = 0; i < keys.length; i++) {

          key = keys[i];
          value = obj[key];

          if (value && value.__supermodel) {

            descendants.push(value);
            checkAndAddDescendantIfModel(value);

          }
        }

      }

      checkAndAddDescendantIfModel(this);

      return descendants;
    }
  },
  __hasAncestors: {
    get: function() {
      return !!this.__ancestors.length;
    }
  },
  __hasDescendants: {
    get: function() {
      return !!this.__descendants.length;
    }
  },
  errors: {
    get: function() {
      var errors = [],
        def = this.__def;
      var validator, error, i, j;

      // Run own validators
      var own = def.validators.slice(0);
      for (i = 0; i < own.length; i++) {
        validator = own[i];
        error = validator.call(this, this);

        if (error) {
          errors.push(new ValidationError(this, error, validator));
        }
      }

      // Run through keys and evaluate validators
      var keys = this.__keys;
      var value, key, itemDef;

      for (i = 0; i < keys.length; i++) {

        key = keys[i];

        // If we are an Array with an item definition
        // then we have to look into the Array for our value
        // and also get hold of the wrapper. We only need to 
        // do this if the key is not a property of the array.
        // We check the defs to work this out (i.e. 0, 1, 2).
        // todo: This could be better to check !NaN on the key?
        if (def.isArray && def.def && (!def.defs || !(key in def.defs))) {

          // If we are an Array with a simple item definition 
          // or a reference to a simple type definition
          // substitute the value with the wrapper we get from the
          // create factory function. Otherwise set the value to 
          // the real value of the property.
          itemDef = def.def;

          if (itemDef.isSimple) {
            value = itemDef.create.wrapper;
            value.value = this[key];
          } else if (itemDef.isReference && itemDef.type.def.isSimple) {
            value = itemDef.type.def.create.wrapper;
            value.value = this[key];
          } else {
            value = this[key];
          }
        } else {

          // Set the value to the wrapped value of the property
          value = this.__[key];
        }

        if (value) {

          if (value.__supermodel) {
            Array.prototype.push.apply(errors, value.errors);
          } else if (value instanceof Wrapper) {

            var wrapperValue = value.getValue(this);
            // `Simple` properties can be identified by not having an
            // assertion. Todo: This may need to become more explicit.
            if (!value._assert) {

              var simple = value.validators;
              for (j = 0; j < simple.length; j++) {
                validator = simple[j];
                error = validator.call(this, wrapperValue, key);

                if (error) {
                  errors.push(new ValidationError(this, error, validator, key));
                }
              }

            } else if (wrapperValue && wrapperValue.__supermodel) {
              Array.prototype.push.apply(errors, wrapperValue.errors);
            } else {
              throw 'just checking';
            }
          }
        }
      }

      return errors;
    }
  }
};

var proto = {
  __get: function(key) {
    return this.__[key].getValue(this);
  },
  __set: function(key, value) {
    this.__[key].setValue(value, this);
  },
  __relativePath: function(to, key) {
    var relativePath = this.__path ? to.substr(this.__path.length + 1) : to;

    if (relativePath) {
      return key ? relativePath + '.' + key : relativePath;
    }
    return key;
  },
  __chain: function(fn) {
    return [this].concat(this.__ancestors).forEach(fn);
  },
  __notifyChange: function(key, newValue, oldValue) {
    var target = this;
    var targetPath = this.__path;
    var eventName = 'set';
    var data = {
      oldValue: oldValue,
      newValue: newValue
    };

    this.emit(eventName, new EmitterEvent(eventName, key, target, data));
    this.emit('change', new EmitterEvent(eventName, key, target, data));
    this.__ancestors.forEach(function(item) {
      var path = item.__relativePath(targetPath, key);
      item.emit('change', new EmitterEvent(eventName, path, target, data));
    });
  },
  __setNotifyChange: function(key, value) {
    var oldValue = this.__get(key);
    this.__set(key, value);
    var newValue = this.__get(key);
    this.__notifyChange(key, newValue, oldValue);
  }
};

module.exports = {
  proto: proto,
  descriptors: descriptors,
};
